#!/usr/bin/env python3
"""
pop - Prompt-Oriented Programming
LLM Code Generator using Ollama models

Usage: pop [options] [prompt]
       pop -fix:<script> "instructions to fix the script"
"""

import argparse
import base64
import json
import os
import pickle
import re
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional, Tuple

# Colors for terminal output
class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    NC = '\033[0m'  # No Color


# Default configuration
DEFAULT_MODEL = "qwen3:latest"
DEFAULT_OUTPUT = "script.py"
MAX_RETRIES = 3
POP_DIR = Path.home() / ".pop"
SESSIONS_DIR = POP_DIR / "sessions"
ACTIVE_DIR = POP_DIR / "active"


def ensure_directories():
    """Create pop directories if they don't exist."""
    SESSIONS_DIR.mkdir(parents=True, exist_ok=True)
    ACTIVE_DIR.mkdir(parents=True, exist_ok=True)


def get_output_filename(base_output: str) -> str:
    """Get incremental output filename to avoid overwriting existing files."""
    output = Path(base_output)

    if not output.exists():
        return str(output)

    # Extract components
    parent = output.parent
    stem = output.stem
    suffix = output.suffix

    counter = 1
    while True:
        if suffix:
            new_output = parent / f"{stem}-{counter}{suffix}"
        else:
            new_output = parent / f"{output.name}-{counter}"

        if not new_output.exists():
            return str(new_output)
        counter += 1


def detect_language(filepath: str, specified_lang: Optional[str] = None) -> str:
    """Detect programming language from file."""
    if specified_lang:
        return specified_lang

    path = Path(filepath)

    # Check shebang first
    if path.exists():
        try:
            with open(path, 'r') as f:
                first_line = f.readline()
                if 'python' in first_line:
                    return 'python'
                if 'bash' in first_line or '/bin/sh' in first_line:
                    return 'bash'
                if 'node' in first_line:
                    return 'javascript'
                if 'ruby' in first_line:
                    return 'ruby'
                if 'perl' in first_line:
                    return 'perl'
        except:
            pass

    # Fall back to extension
    ext_map = {
        '.py': 'python',
        '.sh': 'bash',
        '.bash': 'bash',
        '.js': 'javascript',
        '.rb': 'ruby',
        '.pl': 'perl',
        '.php': 'php',
    }
    return ext_map.get(path.suffix, 'unknown')


def verify_syntax(filepath: str, lang: str) -> str:
    """Verify syntax of generated code. Returns empty string on success, error message on failure."""
    path = Path(filepath)

    if not path.exists() or path.stat().st_size == 0:
        return "File is empty or does not exist"

    try:
        if lang in ('python', 'py'):
            result = subprocess.run(
                ['python3', '-m', 'py_compile', filepath],
                capture_output=True, text=True
            )
            if result.returncode != 0:
                return result.stderr.strip()
            return ""

        elif lang in ('bash', 'sh', 'shell'):
            result = subprocess.run(
                ['bash', '-n', filepath],
                capture_output=True, text=True
            )
            if result.returncode != 0:
                return result.stderr.strip()
            return ""

        elif lang in ('javascript', 'js'):
            if subprocess.run(['which', 'node'], capture_output=True).returncode == 0:
                result = subprocess.run(
                    ['node', '--check', filepath],
                    capture_output=True, text=True
                )
                if result.returncode != 0:
                    return result.stderr.strip()
            return ""

        elif lang in ('ruby', 'rb'):
            if subprocess.run(['which', 'ruby'], capture_output=True).returncode == 0:
                result = subprocess.run(
                    ['ruby', '-c', filepath],
                    capture_output=True, text=True
                )
                if 'Syntax OK' not in result.stdout and result.returncode != 0:
                    return result.stderr.strip()
            return ""

        elif lang in ('perl', 'pl'):
            if subprocess.run(['which', 'perl'], capture_output=True).returncode == 0:
                result = subprocess.run(
                    ['perl', '-c', filepath],
                    capture_output=True, text=True
                )
                if 'syntax OK' not in result.stderr and result.returncode != 0:
                    return result.stderr.strip()
            return ""

        else:
            return ""  # Can't verify unknown languages, assume OK

    except Exception as e:
        return str(e)


def verify_completeness(model: str, original_prompt: str, code_file: str, hide_thinking: bool) -> str:
    """Verify completeness using the model. Returns JSON response."""
    try:
        with open(code_file, 'r') as f:
            code = f.read()
    except:
        return '{"complete": true}'

    verify_prompt = f'''You are a code reviewer. Analyze if this code fully implements the requirements.

ORIGINAL REQUIREMENTS:
{original_prompt}

GENERATED CODE:
{code}

Respond with ONLY valid JSON (no markdown, no code blocks, no explanation):
{{"complete": true}} if the code fully meets requirements and is syntactically complete
{{"complete": false, "issues": ["issue1", "issue2"]}} if incomplete or broken

Check for:
- Code appears truncated or cut off mid-statement
- Missing required functionality from the prompt
- Incomplete function definitions or class structures
- Missing imports or dependencies that would cause runtime errors'''

    cmd = ['ollama', 'run']
    if hide_thinking:
        cmd.append('--hidethinking')
    cmd.extend([model, verify_prompt])

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
        response = result.stdout

        # Try to extract JSON from response
        match = re.search(r'\{[^}]*\}', response)
        if match:
            return match.group()
        return '{"complete": true}'
    except:
        return '{"complete": true}'


def extract_issues(json_str: str) -> str:
    """Extract issues from verification response."""
    try:
        data = json.loads(json_str)
        issues = data.get('issues', [])
        return '\n'.join(f'- {issue}' for issue in issues)
    except:
        return ""


def detect_missing_modules(filepath: str, lang: str) -> Tuple[list, str]:
    """
    Try to run/parse the script and detect missing modules.
    Returns (list of missing modules, full error output).
    """
    missing_modules = []
    error_output = ""

    if lang not in ('python', 'py'):
        return missing_modules, error_output

    # Try running with python to catch import errors
    try:
        result = subprocess.run(
            ['python3', '-c', f'import ast; ast.parse(open("{filepath}").read())'],
            capture_output=True, text=True, timeout=10
        )
        if result.returncode != 0:
            error_output = result.stderr
    except:
        pass

    # Try to actually import/run to catch ModuleNotFoundError
    try:
        result = subprocess.run(
            ['python3', filepath],
            capture_output=True, text=True, timeout=10,
            env={**os.environ, 'PYTHONDONTWRITEBYTECODE': '1'}
        )
        error_output = result.stderr

        # Parse for ModuleNotFoundError or ImportError
        for line in error_output.split('\n'):
            if 'ModuleNotFoundError' in line or 'ImportError' in line:
                # Extract module name
                match = re.search(r"No module named ['\"]([^'\"]+)['\"]", line)
                if match:
                    module = match.group(1).split('.')[0]  # Get base module
                    if module not in missing_modules:
                        missing_modules.append(module)
    except subprocess.TimeoutExpired:
        error_output = "Script execution timed out"
    except Exception as e:
        error_output = str(e)

    return missing_modules, error_output


def analyze_script_issues(model: str, code: str, user_instructions: str,
                          runtime_errors: str, hide_thinking: bool) -> dict:
    """
    Ask the model to analyze the script and identify issues.
    Returns dict with 'issues', 'missing_modules', and 'fixes'.
    """
    analyze_prompt = f'''Analyze this script for issues and problems.

SCRIPT:
```
{code}
```

USER'S FIX REQUEST:
{user_instructions}

RUNTIME ERRORS (if any):
{runtime_errors if runtime_errors else "No runtime errors detected"}

Respond with ONLY valid JSON (no markdown, no explanation):
{{
    "issues": ["issue 1 description", "issue 2 description"],
    "missing_modules": ["module1", "module2"],
    "fixes_to_apply": ["fix 1 description", "fix 2 description"]
}}

Identify:
- Syntax errors or typos
- Missing imports or modules that need to be installed via pip
- Logic errors
- Issues mentioned in the user's fix request
- Any other problems that would prevent the script from running'''

    cmd = ['ollama', 'run']
    if hide_thinking:
        cmd.append('--hidethinking')
    cmd.extend([model, analyze_prompt])

    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
        response = result.stdout

        # Try to extract JSON from response
        match = re.search(r'\{[^{}]*\}', response, re.DOTALL)
        if match:
            try:
                return json.loads(match.group())
            except:
                pass
    except:
        pass

    return {"issues": [], "missing_modules": [], "fixes_to_apply": []}


def generate_requirements_file(modules: list, output_dir: str, script_name: str) -> Optional[str]:
    """
    Generate a requirements.txt file for missing modules.
    Returns the path to the requirements file, or None if no modules.
    """
    if not modules:
        return None

    # Map common module names to pip package names
    pip_name_map = {
        'cv2': 'opencv-python',
        'PIL': 'Pillow',
        'sklearn': 'scikit-learn',
        'yaml': 'PyYAML',
        'bs4': 'beautifulsoup4',
        'dotenv': 'python-dotenv',
    }

    pip_packages = []
    for mod in modules:
        pip_name = pip_name_map.get(mod, mod)
        if pip_name not in pip_packages:
            pip_packages.append(pip_name)

    req_file = Path(output_dir) / f"{Path(script_name).stem}_requirements.txt"
    with open(req_file, 'w') as f:
        f.write(f"# Requirements for {script_name}\n")
        f.write(f"# Install with: pip install -r {req_file.name}\n")
        f.write("#\n")
        for pkg in pip_packages:
            f.write(f"{pkg}\n")

    return str(req_file)


def add_installation_header(code: str, requirements_file: str, missing_modules: list,
                            lang: str) -> str:
    """Add installation instructions as comments at the top of the script."""
    if not missing_modules or lang not in ('python', 'py'):
        return code

    lines = code.split('\n')
    shebang = ""
    code_start = 0

    # Preserve shebang if present
    if lines and lines[0].startswith('#!'):
        shebang = lines[0] + '\n'
        code_start = 1

    req_basename = Path(requirements_file).name
    modules_list = ', '.join(missing_modules)

    header = f'''{shebang}# ============================================================
# DEPENDENCIES REQUIRED
# ============================================================
# This script requires the following modules: {modules_list}
#
# Install dependencies with ONE of these methods:
#
#   Option 1 - Using requirements file:
#     pip install -r {req_basename}
#
#   Option 2 - Install directly:
#     pip install {' '.join(missing_modules)}
#
# ============================================================

'''
    return header + '\n'.join(lines[code_start:])


def ensure_shebang(code: str, language: Optional[str] = None) -> str:
    """Ensure code has a valid shebang line at the beginning."""
    lines = code.split('\n')

    if lines and lines[0].strip().startswith('#!'):
        return code

    # Detect language if not specified
    if not language:
        if 'import ' in code or 'def ' in code or 'class ' in code:
            language = 'python'
        elif 'function ' in code or 'const ' in code or 'let ' in code:
            language = 'javascript'
        elif 'echo ' in code or '[[' in code or 'if [' in code:
            language = 'bash'

    # Determine appropriate shebang
    shebang_map = {
        'python': '#!/usr/bin/env python3',
        'py': '#!/usr/bin/env python3',
        'bash': '#!/bin/bash',
        'sh': '#!/bin/bash',
        'shell': '#!/bin/bash',
        'javascript': '#!/usr/bin/env node',
        'js': '#!/usr/bin/env node',
        'node': '#!/usr/bin/env node',
        'ruby': '#!/usr/bin/env ruby',
        'rb': '#!/usr/bin/env ruby',
        'perl': '#!/usr/bin/env perl',
        'pl': '#!/usr/bin/env perl',
        'php': '#!/usr/bin/env php',
    }

    shebang = shebang_map.get(language)
    if shebang:
        return f"{shebang}\n{code}"
    return code


def strip_comments(code: str, language: Optional[str] = None) -> str:
    """Remove comments from code while preserving functionality."""
    if not language:
        if code.strip().startswith('#!/usr/bin/env python') or 'import ' in code or 'def ' in code:
            language = 'python'
        elif code.strip().startswith('#!/bin/bash') or code.strip().startswith('#!/bin/sh'):
            language = 'bash'

    if language in ('python', 'py'):
        lines = code.split('\n')
        cleaned_lines = []
        for i, line in enumerate(lines):
            if i == 0 and line.strip().startswith('#!'):
                cleaned_lines.append(line)
            elif '#' in line:
                # Simple approach: remove # comments not in strings
                in_string = False
                quote_char = None
                result = []
                for j, char in enumerate(line):
                    if char in ('"', "'") and (j == 0 or line[j-1] != '\\'):
                        if not in_string:
                            in_string = True
                            quote_char = char
                        elif char == quote_char:
                            in_string = False
                    if char == '#' and not in_string:
                        break
                    result.append(char)
                cleaned_lines.append(''.join(result).rstrip())
            else:
                cleaned_lines.append(line)
        code = '\n'.join(cleaned_lines)
        # Remove docstrings
        code = re.sub(r'^\s*""".*?"""\s*$', '', code, flags=re.MULTILINE | re.DOTALL)
        code = re.sub(r"^\s*'''.*?'''\s*$", '', code, flags=re.MULTILINE | re.DOTALL)

    elif language in ('bash', 'sh', 'shell'):
        lines = code.split('\n')
        cleaned_lines = []
        for i, line in enumerate(lines):
            if i == 0 and line.strip().startswith('#!'):
                cleaned_lines.append(line)
            elif '#' in line:
                idx = line.find('#')
                cleaned_lines.append(line[:idx].rstrip())
            else:
                cleaned_lines.append(line)
        code = '\n'.join(cleaned_lines)

    elif language in ('javascript', 'js', 'typescript', 'ts'):
        code = re.sub(r'//.*$', '', code, flags=re.MULTILINE)
        code = re.sub(r'/\*.*?\*/', '', code, flags=re.DOTALL)

    # Remove excessive blank lines
    code = re.sub(r'\n\s*\n\s*\n+', '\n\n', code)
    return code


def extract_code_blocks(text: str, language: Optional[str] = None) -> Tuple[str, Optional[str]]:
    """Extract code blocks from markdown-formatted text."""
    pattern = r'```(\w+)?\n(.*?)```'
    matches = re.findall(pattern, text, re.DOTALL)

    if not matches:
        return (text, language)

    if language:
        matches = [(lang, code) for lang, code in matches if lang and lang.lower() == language.lower()]

    if not matches:
        return ("", language)

    detected_lang, code = matches[0]
    return (code.strip(), detected_lang or language)


def list_sessions():
    """List all active and past sessions."""
    print(f"{Colors.CYAN}=== Past Sessions (Last 20) ==={Colors.NC}")

    past_count = 0
    if SESSIONS_DIR.exists():
        meta_files = sorted(SESSIONS_DIR.glob("*.meta"), key=lambda x: x.stat().st_mtime)[-20:]

        for meta_file in meta_files:
            session_id = meta_file.stem
            active_file = ACTIVE_DIR / f"{session_id}.session"

            if active_file.exists():
                continue  # Skip active sessions

            try:
                meta = {}
                with open(meta_file) as f:
                    for line in f:
                        if '=' in line:
                            key, val = line.strip().split('=', 1)
                            meta[key] = val.strip('"')

                status = meta.get('STATUS', '')
                if status == 'failed':
                    icon, color = '✗', Colors.RED
                else:
                    icon, color = '✓', Colors.GREEN

                print(f"{color}{icon}{Colors.NC} {session_id}")
                print(f"  Time: {meta.get('START_TIME', '')} → {meta.get('END_TIME', '')}")
                print(f"  Model: {meta.get('MODEL_NAME', '')}")
                print(f"  Output: {meta.get('OUTPUT_FILE', '')}")
                prompt_text = meta.get('PROMPT_TEXT', '')[:60]
                print(f"  Prompt: {prompt_text}...")
                print(f"  Log: {SESSIONS_DIR}/{session_id}.log")
                print()
                past_count += 1
            except:
                pass

    if past_count == 0:
        print(f"{Colors.YELLOW}No past sessions{Colors.NC}")

    print()
    print(f"{Colors.CYAN}=== Active Sessions ==={Colors.NC}")

    active_count = 0
    if ACTIVE_DIR.exists():
        for session_file in ACTIVE_DIR.glob("*.session"):
            session_id = session_file.stem
            try:
                pid = int(session_file.read_text().strip())

                # Check if process is running
                try:
                    os.kill(pid, 0)
                except OSError:
                    session_file.unlink()
                    continue

                meta_file = SESSIONS_DIR / f"{session_id}.meta"
                if meta_file.exists():
                    meta = {}
                    with open(meta_file) as f:
                        for line in f:
                            if '=' in line:
                                key, val = line.strip().split('=', 1)
                                meta[key] = val.strip('"')

                    print(f"{Colors.GREEN}● {Colors.NC}{session_id} (PID: {pid})")
                    print(f"  Started: {meta.get('START_TIME', '')}")
                    print(f"  Model: {meta.get('MODEL_NAME', '')}")
                    print(f"  Output: {meta.get('OUTPUT_FILE', '')}")
                    prompt_text = meta.get('PROMPT_TEXT', '')[:60]
                    print(f"  Prompt: {prompt_text}...")
                    print()
                    active_count += 1
            except:
                pass

    if active_count == 0:
        print(f"{Colors.YELLOW}No active sessions{Colors.NC}")


def list_models():
    """List available Ollama models."""
    print(f"{Colors.CYAN}=== Available Ollama Models ==={Colors.NC}")

    try:
        result = subprocess.run(['ollama', 'list'], capture_output=True, text=True)
        if result.returncode != 0 or not result.stdout.strip():
            print(f"{Colors.RED}✗ No models found or Ollama is not running{Colors.NC}")
            print(f"{Colors.YELLOW}Install models with: ollama pull <model>{Colors.NC}")
            sys.exit(1)

        print(result.stdout)
    except FileNotFoundError:
        print(f"{Colors.RED}✗ Ollama not found. Please install Ollama first.{Colors.NC}")
        sys.exit(1)


def verify_model_exists(model: str) -> bool:
    """Check if the specified model exists."""
    try:
        result = subprocess.run(['ollama', 'list'], capture_output=True, text=True)
        return model in result.stdout
    except:
        return False


def run_generation(session_id: str, model: str, original_prompt: str, output: str,
                   lang: Optional[str], log_file: str, meta_file: str, active_file: str,
                   hide_thinking: bool, minimal_mode: bool, do_verify: bool, max_retries: int):
    """Run the code generation process with verification loop."""

    # Write session header to log
    with open(log_file, 'a') as log:
        log.write(f"=== pop Session: {session_id} ===\n")
        log.write(f"Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        log.write(f"Model: {model}\n")
        log.write(f"Output: {output}\n")
        log.write(f"Verification: {do_verify}\n")
        log.write(f"Prompt: {original_prompt}\n\n")

    # Verification loop
    attempt = 1
    max_attempts = max_retries + 1
    status = "success"
    verified = "false"
    current_prompt = original_prompt

    while attempt <= max_attempts:
        with open(log_file, 'a') as log:
            log.write(f"=== Generation Attempt {attempt}/{max_attempts} ===\n")

        # Build enhanced prompt
        if minimal_mode:
            enhanced_prompt = f"""{current_prompt}

CRITICAL INSTRUCTIONS:
- Output ONLY executable code in a single code block
- NO explanations, NO comments, NO documentation
- NO text before or after the code block
- Code must be production-ready and executable immediately"""
        else:
            enhanced_prompt = f"""{current_prompt}

IMPORTANT: Respond with ONLY the executable code inside a single code block. No explanations, no comments, no text before or after the code block."""

        # Run ollama
        cmd = ['ollama', 'run']
        if hide_thinking:
            cmd.append('--hidethinking')
        cmd.extend([model, enhanced_prompt])

        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            response = result.stdout

            # Log raw response
            with open(log_file, 'a') as log:
                log.write(response + "\n")

            # Extract code
            code, detected_lang = extract_code_blocks(response, lang)

            if code:
                # Ensure shebang
                code = ensure_shebang(code, detected_lang or lang)

                # Strip comments if minimal mode
                if minimal_mode:
                    code = strip_comments(code, detected_lang or lang)

                # Write output file
                with open(output, 'w') as f:
                    f.write(code)
                os.chmod(output, 0o755)

                # Skip verification if disabled
                if not do_verify:
                    with open(log_file, 'a') as log:
                        log.write("\n=== Result (verification skipped) ===\n")
                        log.write(f"✓ Script saved to: {output}\n")
                    verified = "skipped"
                    break

                # Detect language for syntax checking
                detected = detect_language(output, lang)
                with open(log_file, 'a') as log:
                    log.write(f"\n=== Verification (attempt {attempt}) ===\n")
                    log.write(f"Detected language: {detected}\n")

                # Step 1: Syntax verification
                syntax_result = verify_syntax(output, detected)
                if syntax_result:
                    with open(log_file, 'a') as log:
                        log.write(f"✗ Syntax error: {syntax_result}\n")

                    if attempt < max_attempts:
                        current_prompt = f"""{original_prompt}

IMPORTANT: Your previous attempt had a syntax error:
{syntax_result}

Please generate COMPLETE, syntactically correct code that compiles/parses without errors."""
                        attempt += 1
                        continue
                    else:
                        with open(log_file, 'a') as log:
                            log.write("✗ Max retries reached with syntax errors\n")
                        status = "failed"
                        break

                with open(log_file, 'a') as log:
                    log.write("✓ Syntax check passed\n")

                # Step 2: Completeness verification
                with open(log_file, 'a') as log:
                    log.write("Running completeness check...\n")

                completeness_result = verify_completeness(model, original_prompt, output, hide_thinking)

                with open(log_file, 'a') as log:
                    log.write(f"Completeness result: {completeness_result}\n")

                if '"complete": false' in completeness_result or '"complete":false' in completeness_result:
                    issues = extract_issues(completeness_result)
                    with open(log_file, 'a') as log:
                        log.write(f"✗ Completeness check failed:\n{issues}\n")

                    if attempt < max_attempts:
                        current_prompt = f"""{original_prompt}

IMPORTANT: Your previous attempt was incomplete or had issues:
{issues}

Please generate a COMPLETE, working implementation that addresses ALL requirements and issues above."""
                        attempt += 1
                        continue
                    else:
                        with open(log_file, 'a') as log:
                            log.write("✗ Max retries reached, accepting best effort\n")
                        verified = "partial"
                        break

                # All checks passed
                with open(log_file, 'a') as log:
                    log.write("✓ Completeness check passed\n")
                verified = "true"
                break
            else:
                with open(log_file, 'a') as log:
                    log.write("\n✗ No code extracted from response\n")

                if attempt < max_attempts:
                    current_prompt = f"""{original_prompt}

IMPORTANT: Your previous response did not contain a properly formatted code block.
Please respond with ONLY executable code inside a markdown code block like:
```python
# your code here
```"""
                    attempt += 1
                    continue
                else:
                    status = "failed"
                    break

        except subprocess.TimeoutExpired:
            with open(log_file, 'a') as log:
                log.write("\n✗ Code generation timed out\n")
            status = "failed"
            break
        except Exception as e:
            with open(log_file, 'a') as log:
                log.write(f"\n✗ Code generation failed: {e}\n")
            status = "failed"
            break

    # Final result
    with open(log_file, 'a') as log:
        log.write(f"\n=== Final Result ===\n")
        log.write(f"Attempts: {attempt}\n")
        log.write(f"Verified: {verified}\n")

        if Path(output).exists() and Path(output).stat().st_size > 0 and status == "success":
            log.write(f"✓ Script saved to: {output}\n")
            log.write(f"✓ Session log: {log_file}\n")
        elif Path(output).exists() and Path(output).stat().st_size > 0:
            log.write(f"⚠ Script saved with issues to: {output}\n")
        else:
            log.write("✗ No output generated\n")

    # Update metadata
    end_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    try:
        with open(meta_file, 'r') as f:
            content = f.read()
        content = content.replace('STATUS="running"', f'STATUS="{status}"')
        content = content.replace('END_TIME=""', f'END_TIME="{end_time}"')
        content = content.replace('ATTEMPTS="0"', f'ATTEMPTS="{attempt}"')
        content = content.replace('VERIFIED="false"', f'VERIFIED="{verified}"')
        with open(meta_file, 'w') as f:
            f.write(content)
    except:
        pass

    # Remove from active sessions
    try:
        Path(active_file).unlink()
    except:
        pass


def run_fix(session_id: str, model: str, fix_prompt: str, source_file: str, output: str,
            lang: Optional[str], log_file: str, meta_file: str, active_file: str,
            hide_thinking: bool, minimal_mode: bool, do_verify: bool, max_retries: int):
    """Run the code fix process with verification loop and dependency detection."""

    # Read the source file
    try:
        with open(source_file, 'r') as f:
            original_code = f.read()
    except Exception as e:
        with open(log_file, 'a') as log:
            log.write(f"✗ Failed to read source file: {e}\n")
        return

    # Detect language
    detected_lang = lang or detect_language(source_file)

    # Write session header to log
    with open(log_file, 'a') as log:
        log.write(f"=== pop Fix Session: {session_id} ===\n")
        log.write(f"Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        log.write(f"Model: {model}\n")
        log.write(f"Source: {source_file}\n")
        log.write(f"Output: {output}\n")
        log.write(f"Verification: {do_verify}\n")
        log.write(f"Fix Instructions: {fix_prompt}\n\n")
        log.write(f"=== Original Code ===\n{original_code}\n\n")

    # Phase 1: Analyze original script for issues
    with open(log_file, 'a') as log:
        log.write("=== Analyzing Original Script ===\n")

    # Detect missing modules from runtime
    runtime_missing, runtime_errors = detect_missing_modules(source_file, detected_lang)
    with open(log_file, 'a') as log:
        if runtime_missing:
            log.write(f"Missing modules detected: {', '.join(runtime_missing)}\n")
        if runtime_errors:
            log.write(f"Runtime errors:\n{runtime_errors}\n")

    # Ask model to analyze for issues
    with open(log_file, 'a') as log:
        log.write("Running AI analysis...\n")

    analysis = analyze_script_issues(model, original_code, fix_prompt, runtime_errors, hide_thinking)

    issues_found = analysis.get('issues', [])
    model_missing_modules = analysis.get('missing_modules', [])
    fixes_to_apply = analysis.get('fixes_to_apply', [])

    # Combine missing modules from runtime detection and model analysis
    all_missing_modules = list(set(runtime_missing + model_missing_modules))

    with open(log_file, 'a') as log:
        log.write("\n=== Issues Found ===\n")
        if issues_found:
            for i, issue in enumerate(issues_found, 1):
                log.write(f"  {i}. {issue}\n")
        else:
            log.write("  No specific issues identified\n")

        if all_missing_modules:
            log.write(f"\n=== Missing Dependencies ===\n")
            for mod in all_missing_modules:
                log.write(f"  - {mod}\n")

        if fixes_to_apply:
            log.write(f"\n=== Fixes to Apply ===\n")
            for i, fix in enumerate(fixes_to_apply, 1):
                log.write(f"  {i}. {fix}\n")
        log.write("\n")

    # Build the fix prompt with analysis context
    issues_context = ""
    if issues_found or all_missing_modules or fixes_to_apply:
        issues_context = "\n\nANALYSIS OF ISSUES FOUND:\n"
        if issues_found:
            issues_context += "Issues:\n" + "\n".join(f"- {i}" for i in issues_found) + "\n"
        if all_missing_modules:
            issues_context += f"Missing modules that need imports: {', '.join(all_missing_modules)}\n"
        if fixes_to_apply:
            issues_context += "Fixes needed:\n" + "\n".join(f"- {f}" for f in fixes_to_apply) + "\n"

    base_fix_prompt = f"""Here is an existing script that needs to be fixed/modified:

```
{original_code}
```

TASK: {fix_prompt}
{issues_context}
Respond with the COMPLETE fixed/modified script. Output ONLY the executable code inside a single code block. Include ALL the original code with your fixes applied - do not omit any parts."""

    # Verification loop
    attempt = 1
    max_attempts = max_retries + 1
    status = "success"
    verified = "false"
    current_prompt = base_fix_prompt
    requirements_file = None

    while attempt <= max_attempts:
        with open(log_file, 'a') as log:
            log.write(f"=== Fix Attempt {attempt}/{max_attempts} ===\n")

        # Build enhanced prompt
        if minimal_mode:
            enhanced_prompt = f"""{current_prompt}

CRITICAL INSTRUCTIONS:
- Output ONLY the complete fixed executable code in a single code block
- NO explanations, NO comments about changes, NO documentation
- NO text before or after the code block
- Include the ENTIRE script, not just the changed parts"""
        else:
            enhanced_prompt = current_prompt

        # Run ollama
        cmd = ['ollama', 'run']
        if hide_thinking:
            cmd.append('--hidethinking')
        cmd.extend([model, enhanced_prompt])

        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            response = result.stdout

            # Log raw response
            with open(log_file, 'a') as log:
                log.write(response + "\n")

            # Extract code
            code, detected_lang = extract_code_blocks(response, lang)

            if code:
                # Ensure shebang
                code = ensure_shebang(code, detected_lang or lang)

                # Strip comments if minimal mode
                if minimal_mode:
                    code = strip_comments(code, detected_lang or lang)

                # Write output file
                with open(output, 'w') as f:
                    f.write(code)
                os.chmod(output, 0o755)

                # Skip verification if disabled
                if not do_verify:
                    with open(log_file, 'a') as log:
                        log.write("\n=== Result (verification skipped) ===\n")
                        log.write(f"✓ Fixed script saved to: {output}\n")
                    verified = "skipped"
                    break

                # Detect language for syntax checking
                detected = detect_language(output, lang)
                with open(log_file, 'a') as log:
                    log.write(f"\n=== Verification (attempt {attempt}) ===\n")
                    log.write(f"Detected language: {detected}\n")

                # Step 1: Syntax verification
                syntax_result = verify_syntax(output, detected)
                if syntax_result:
                    with open(log_file, 'a') as log:
                        log.write(f"✗ Syntax error: {syntax_result}\n")

                    if attempt < max_attempts:
                        current_prompt = f"""{base_fix_prompt}

IMPORTANT: Your previous fix attempt had a syntax error:
{syntax_result}

Please provide the COMPLETE fixed script with correct syntax."""
                        attempt += 1
                        continue
                    else:
                        with open(log_file, 'a') as log:
                            log.write("✗ Max retries reached with syntax errors\n")
                        status = "failed"
                        break

                with open(log_file, 'a') as log:
                    log.write("✓ Syntax check passed\n")

                # Step 2: Completeness verification
                with open(log_file, 'a') as log:
                    log.write("Running completeness check...\n")

                completeness_result = verify_completeness(model, fix_prompt, output, hide_thinking)

                with open(log_file, 'a') as log:
                    log.write(f"Completeness result: {completeness_result}\n")

                if '"complete": false' in completeness_result or '"complete":false' in completeness_result:
                    issues = extract_issues(completeness_result)
                    with open(log_file, 'a') as log:
                        log.write(f"✗ Completeness check failed:\n{issues}\n")

                    if attempt < max_attempts:
                        current_prompt = f"""{base_fix_prompt}

IMPORTANT: Your previous fix attempt was incomplete or had issues:
{issues}

Please provide the COMPLETE fixed script that addresses ALL the requested changes."""
                        attempt += 1
                        continue
                    else:
                        with open(log_file, 'a') as log:
                            log.write("✗ Max retries reached, accepting best effort\n")
                        verified = "partial"
                        break

                # All checks passed
                with open(log_file, 'a') as log:
                    log.write("✓ Completeness check passed\n")
                verified = "true"
                break
            else:
                with open(log_file, 'a') as log:
                    log.write("\n✗ No code extracted from response\n")

                if attempt < max_attempts:
                    current_prompt = f"""{base_fix_prompt}

IMPORTANT: Your previous response did not contain a properly formatted code block.
Please respond with the COMPLETE fixed script inside a markdown code block."""
                    attempt += 1
                    continue
                else:
                    status = "failed"
                    break

        except subprocess.TimeoutExpired:
            with open(log_file, 'a') as log:
                log.write("\n✗ Fix operation timed out\n")
            status = "failed"
            break
        except Exception as e:
            with open(log_file, 'a') as log:
                log.write(f"\n✗ Fix operation failed: {e}\n")
            status = "failed"
            break

    # Post-fix: Check for dependencies and generate requirements
    if Path(output).exists() and Path(output).stat().st_size > 0:
        final_lang = detect_language(output, lang)
        fixed_missing, fixed_errors = detect_missing_modules(output, final_lang)

        # Combine with originally detected missing modules
        final_missing = list(set(all_missing_modules + fixed_missing))

        if final_missing:
            with open(log_file, 'a') as log:
                log.write(f"\n=== Dependencies Required ===\n")
                log.write(f"The following modules need to be installed:\n")
                for mod in final_missing:
                    log.write(f"  - {mod}\n")

            # Generate requirements file
            output_dir = str(Path(output).parent) if Path(output).parent != Path('.') else '.'
            requirements_file = generate_requirements_file(final_missing, output_dir, output)

            if requirements_file:
                with open(log_file, 'a') as log:
                    log.write(f"\n✓ Requirements file created: {requirements_file}\n")
                    log.write(f"  Install with: pip install -r {Path(requirements_file).name}\n")

                # Add installation header to the fixed script
                with open(output, 'r') as f:
                    fixed_code = f.read()
                fixed_code = add_installation_header(fixed_code, requirements_file, final_missing, final_lang)
                with open(output, 'w') as f:
                    f.write(fixed_code)

    # Final result
    with open(log_file, 'a') as log:
        log.write(f"\n=== Final Result ===\n")
        log.write(f"Attempts: {attempt}\n")
        log.write(f"Verified: {verified}\n")

        # Log issues that were found and fixed
        if issues_found or fixes_to_apply:
            log.write(f"\n=== Issues Addressed ===\n")
            if issues_found:
                log.write("Issues found:\n")
                for issue in issues_found:
                    log.write(f"  ✓ {issue}\n")
            if fixes_to_apply:
                log.write("Fixes applied:\n")
                for fix in fixes_to_apply:
                    log.write(f"  ✓ {fix}\n")

        if Path(output).exists() and Path(output).stat().st_size > 0 and status == "success":
            log.write(f"\n✓ Fixed script saved to: {output}\n")
            if requirements_file:
                log.write(f"✓ Requirements file: {requirements_file}\n")
            log.write(f"✓ Session log: {log_file}\n")
        elif Path(output).exists() and Path(output).stat().st_size > 0:
            log.write(f"\n⚠ Fixed script saved with issues to: {output}\n")
        else:
            log.write("\n✗ No output generated\n")

    # Update metadata
    end_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    try:
        with open(meta_file, 'r') as f:
            content = f.read()
        content = content.replace('STATUS="running"', f'STATUS="{status}"')
        content = content.replace('END_TIME=""', f'END_TIME="{end_time}"')
        content = content.replace('ATTEMPTS="0"', f'ATTEMPTS="{attempt}"')
        content = content.replace('VERIFIED="false"', f'VERIFIED="{verified}"')
        with open(meta_file, 'w') as f:
            f.write(content)
    except:
        pass

    # Remove from active sessions
    try:
        Path(active_file).unlink()
    except:
        pass


def run_daemon_mode():
    """Run in daemon mode - called when spawned as background process."""
    import pickle
    import base64

    # Read serialized arguments from environment
    args_data = os.environ.get('POP_DAEMON_ARGS')
    if not args_data:
        sys.exit(1)

    try:
        args = pickle.loads(base64.b64decode(args_data))
    except:
        sys.exit(1)

    mode = args['mode']
    if mode == 'generate':
        run_generation(
            args['session_id'], args['model'], args['prompt'], args['output'],
            args['lang'], args['log_file'], args['meta_file'], args['active_file'],
            args['hide_thinking'], args['minimal'], args['do_verify'], args['max_retries']
        )
    elif mode == 'fix':
        run_fix(
            args['session_id'], args['model'], args['prompt'], args['fix_file'],
            args['output'], args['lang'], args['log_file'], args['meta_file'],
            args['active_file'], args['hide_thinking'], args['minimal'],
            args['do_verify'], args['max_retries']
        )
    sys.exit(0)


def main():
    # Check for daemon mode first (before anything else)
    if '--_daemon' in sys.argv:
        run_daemon_mode()
        return

    ensure_directories()

    # Check for commands first
    if len(sys.argv) > 1:
        if sys.argv[1] == 'list':
            list_sessions()
            sys.exit(0)
        elif sys.argv[1] == 'model':
            list_models()
            sys.exit(0)

    # Pre-process arguments to extract -fix: parameter
    fix_file = None
    filtered_args = []
    for arg in sys.argv[1:]:
        if arg.startswith('-fix:'):
            fix_file = arg[5:]  # Extract filename after -fix:
        else:
            filtered_args.append(arg)

    # Parse arguments
    parser = argparse.ArgumentParser(
        description='Generate code using Ollama models and extract it to executable files.',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Commands:
  pop list         Show all active and past pop sessions
  pop model        List all available Ollama models

Fix Mode:
  pop -fix:<script> "instructions"   Fix an existing script
  Output will be saved to <script>_popfix

Verification:
  By default, pop verifies generated code for syntax errors and completeness.
  If verification fails, it automatically retries up to 3 times with feedback.
  Use --no-verify to skip verification for faster (but less reliable) output.

Examples:
  pop "write a python script that lists files"
  pop -m llama3.2 "write a csv parser" -o csvcut.py -l python
  pop -f my-prompt.txt -o output.sh -l bash
  echo "write a port scanner" | pop -o portscan.py
  pop -fix:./myscript.py "add error handling and fix any syntax errors"
'''
    )

    parser.add_argument('-m', '--model', default=DEFAULT_MODEL,
                        help=f'Select Ollama model (default: {DEFAULT_MODEL})')
    parser.add_argument('-f', '--file', dest='input_file',
                        help='Read prompt from file')
    parser.add_argument('-o', '--output', default=DEFAULT_OUTPUT,
                        help=f'Output file path (default: {DEFAULT_OUTPUT})')
    parser.add_argument('-l', '--lang',
                        help='Language filter for code extraction (python, bash, etc.)')
    parser.add_argument('--minimal', action='store_true',
                        help='Enable minimal mode (strongest prompts + strip comments)')
    parser.add_argument('--thinking', action='store_true',
                        help='Show model thinking process (hidden by default)')
    parser.add_argument('--hidethinking', action='store_true',
                        help='Explicitly hide model thinking process (default behavior)')
    parser.add_argument('--no-verify', action='store_true', dest='no_verify',
                        help='Skip output verification (verification enabled by default)')
    parser.add_argument('prompt', nargs='?', default=None,
                        help='The prompt for code generation')

    args = parser.parse_args(filtered_args)

    # Determine hide_thinking (default True unless --thinking specified)
    hide_thinking = not args.thinking

    # Determine verification
    do_verify = not args.no_verify

    # Determine input source (priority: file > stdin > argument)
    prompt = None

    if args.input_file:
        if not Path(args.input_file).exists():
            print(f"{Colors.RED}✗ File not found: {args.input_file}{Colors.NC}", file=sys.stderr)
            sys.exit(1)
        prompt = Path(args.input_file).read_text()
    elif not sys.stdin.isatty():
        stdin_content = sys.stdin.read()
        if args.prompt:
            prompt = f"{args.prompt}\n\n{stdin_content}"
        else:
            prompt = stdin_content
    elif args.prompt:
        prompt = args.prompt
    else:
        print(f"{Colors.RED}✗ No prompt provided{Colors.NC}", file=sys.stderr)
        parser.print_help()
        sys.exit(1)

    if not prompt or not prompt.strip():
        print(f"{Colors.RED}✗ Empty prompt{Colors.NC}", file=sys.stderr)
        sys.exit(1)

    # Verify model exists
    if not verify_model_exists(args.model):
        print(f"{Colors.RED}✗ Model not found: {args.model}{Colors.NC}", file=sys.stderr)
        print("Available models:", file=sys.stderr)
        subprocess.run(['ollama', 'list'], stderr=sys.stderr)
        sys.exit(1)

    # Handle fix mode
    if fix_file:
        # Validate fix file exists
        if not Path(fix_file).exists():
            print(f"{Colors.RED}✗ Fix target file not found: {fix_file}{Colors.NC}", file=sys.stderr)
            sys.exit(1)

        # Generate output filename: <script>_popfix
        output = f"{fix_file}_popfix"

        # Generate unique session ID
        session_id = f"pop-fix-{datetime.now().strftime('%Y%m%d-%H%M%S')}-{os.getpid()}"
        session_log = SESSIONS_DIR / f"{session_id}.log"
        session_meta = SESSIONS_DIR / f"{session_id}.meta"
        session_active = ACTIVE_DIR / f"{session_id}.session"

        # Detect language from source file
        lang = args.lang or detect_language(fix_file)

        # Save session metadata
        with open(session_meta, 'w') as f:
            f.write(f'START_TIME="{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}"\n')
            f.write(f'MODEL_NAME="{args.model}"\n')
            f.write(f'SOURCE_FILE="{fix_file}"\n')
            f.write(f'OUTPUT_FILE="{output}"\n')
            f.write(f'PROMPT_TEXT="{prompt}"\n')
            f.write(f'MODE="fix"\n')
            f.write('STATUS="running"\n')
            f.write('END_TIME=""\n')
            f.write('ATTEMPTS="0"\n')
            f.write('VERIFIED="false"\n')

        # Serialize arguments for daemon process
        daemon_args = {
            'mode': 'fix',
            'session_id': session_id,
            'model': args.model,
            'prompt': prompt,
            'fix_file': fix_file,
            'output': output,
            'lang': lang,
            'log_file': str(session_log),
            'meta_file': str(session_meta),
            'active_file': str(session_active),
            'hide_thinking': hide_thinking,
            'minimal': args.minimal,
            'do_verify': do_verify,
            'max_retries': MAX_RETRIES
        }

        # Spawn fully detached daemon process with serialized args
        env = os.environ.copy()
        env['POP_DAEMON_ARGS'] = base64.b64encode(pickle.dumps(daemon_args)).decode()

        devnull = open(os.devnull, 'r+b')
        proc = subprocess.Popen(
            [sys.executable, __file__, '--_daemon'],
            stdin=devnull,
            stdout=devnull,
            stderr=devnull,
            start_new_session=True,
            close_fds=True,
            env=env
        )
        with open(str(session_active), 'w') as f:
            f.write(str(proc.pid))
        devnull.close()
        daemon_pid = proc.pid

        # Print info and exit immediately
        print(f"{Colors.GREEN}✓ pop fix session started: {Colors.BLUE}{session_id}{Colors.NC}")
        print(f"{Colors.GREEN}✓ Model: {Colors.BLUE}{args.model}{Colors.NC}")
        print(f"{Colors.GREEN}✓ Fixing: {Colors.BLUE}{fix_file}{Colors.NC}")
        print(f"{Colors.GREEN}✓ Output will be saved to: {Colors.BLUE}{output}{Colors.NC}")
        if do_verify:
            print(f"{Colors.GREEN}✓ Verification: {Colors.BLUE}enabled (max {MAX_RETRIES} retries){Colors.NC}")
        else:
            print(f"{Colors.YELLOW}✓ Verification: {Colors.BLUE}disabled{Colors.NC}")
        print(f"{Colors.GREEN}✓ Session log: {Colors.BLUE}{session_log}{Colors.NC}")
        print()
        print(f"{Colors.YELLOW}Fix running in background (PID: {daemon_pid}){Colors.NC}")
        print(f"{Colors.YELLOW}Use 'pop list' to check session status{Colors.NC}")
        print(f"{Colors.YELLOW}Use 'tail -f {session_log}' to follow progress{Colors.NC}")
        sys.exit(0)

    else:
        # Normal generation mode
        # Generate unique session ID
        session_id = f"pop-{datetime.now().strftime('%Y%m%d-%H%M%S')}-{os.getpid()}"
        session_log = SESSIONS_DIR / f"{session_id}.log"
        session_meta = SESSIONS_DIR / f"{session_id}.meta"
        session_active = ACTIVE_DIR / f"{session_id}.session"

        # Get incremental output filename
        output = get_output_filename(args.output)

        # Save session metadata
        with open(session_meta, 'w') as f:
            f.write(f'START_TIME="{datetime.now().strftime("%Y-%m-%d %H:%M:%S")}"\n')
            f.write(f'MODEL_NAME="{args.model}"\n')
            f.write(f'OUTPUT_FILE="{output}"\n')
            f.write(f'PROMPT_TEXT="{prompt}"\n')
            f.write('STATUS="running"\n')
            f.write('END_TIME=""\n')
            f.write('ATTEMPTS="0"\n')
            f.write('VERIFIED="false"\n')

        # Serialize arguments for daemon process
        daemon_args = {
            'mode': 'generate',
            'session_id': session_id,
            'model': args.model,
            'prompt': prompt,
            'output': output,
            'lang': args.lang,
            'log_file': str(session_log),
            'meta_file': str(session_meta),
            'active_file': str(session_active),
            'hide_thinking': hide_thinking,
            'minimal': args.minimal,
            'do_verify': do_verify,
            'max_retries': MAX_RETRIES
        }

        # Spawn fully detached daemon process with serialized args
        env = os.environ.copy()
        env['POP_DAEMON_ARGS'] = base64.b64encode(pickle.dumps(daemon_args)).decode()

        devnull = open(os.devnull, 'r+b')
        proc = subprocess.Popen(
            [sys.executable, __file__, '--_daemon'],
            stdin=devnull,
            stdout=devnull,
            stderr=devnull,
            start_new_session=True,
            close_fds=True,
            env=env
        )
        with open(str(session_active), 'w') as f:
            f.write(str(proc.pid))
        devnull.close()
        daemon_pid = proc.pid

        # Print info and exit immediately
        print(f"{Colors.GREEN}✓ pop session started: {Colors.BLUE}{session_id}{Colors.NC}")
        print(f"{Colors.GREEN}✓ Model: {Colors.BLUE}{args.model}{Colors.NC}")
        print(f"{Colors.GREEN}✓ Output will be saved to: {Colors.BLUE}{output}{Colors.NC}")
        if do_verify:
            print(f"{Colors.GREEN}✓ Verification: {Colors.BLUE}enabled (max {MAX_RETRIES} retries){Colors.NC}")
        else:
            print(f"{Colors.YELLOW}✓ Verification: {Colors.BLUE}disabled{Colors.NC}")
        print(f"{Colors.GREEN}✓ Session log: {Colors.BLUE}{session_log}{Colors.NC}")
        print()
        print(f"{Colors.YELLOW}Generation running in background (PID: {daemon_pid}){Colors.NC}")
        print(f"{Colors.YELLOW}Use 'pop list' to check session status{Colors.NC}")
        print(f"{Colors.YELLOW}Use 'tail -f {session_log}' to follow progress{Colors.NC}")
        sys.exit(0)


if __name__ == '__main__':
    main()
