#!/bin/bash
# pop - Prompt-Oriented Programming: LLM Code Generator
# Usage: pop [options] [prompt]

set -e

# Default values
OUTPUT="script.py"
LANG=""
MODEL="qwen3:latest"
INPUT_FILE=""
PROMPT=""
HIDE_THINKING=true  # Hide thinking by default
MINIMAL_MODE=false  # Minimal mode disabled by default
POP_DIR="$HOME/.pop"
SESSIONS_DIR="$POP_DIR/sessions"
ACTIVE_DIR="$POP_DIR/active"

# Function to get incremental output filename
get_output_filename() {
    local base_output="$1"
    local output="$base_output"
    local counter=1

    # If file doesn't exist, use it as-is
    if [ ! -f "$output" ]; then
        echo "$output"
        return
    fi

    # Extract directory, basename, and extension
    local dir=$(dirname "$output")
    local filename=$(basename "$output")
    local name="${filename%.*}"
    local ext="${filename##*.}"

    # If no extension (e.g., "script"), treat whole name as basename
    if [ "$name" = "$ext" ]; then
        ext=""
    fi

    # Find available filename
    while [ -f "$output" ]; do
        if [ -n "$ext" ]; then
            output="${dir}/${name}-${counter}.${ext}"
        else
            output="${dir}/${filename}-${counter}"
        fi
        ((counter++))
    done

    echo "$output"
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Create pop directories if they don't exist
mkdir -p "$SESSIONS_DIR" "$ACTIVE_DIR"

# Function to show usage
show_usage() {
    cat << EOF
Usage: pop [options] [prompt]

Generate code using Ollama models and extract it to executable files.

Options:
  -m MODEL        Select Ollama model (default: qwen3:latest)
  -f FILE         Read prompt from file
  -o OUTPUT       Output file path (default: script.py)
  -l LANG         Language filter for code extraction (python, bash, etc.)
  --minimal       Enable minimal mode (strongest prompts + strip comments)
  --thinking      Show model thinking process (hidden by default)
  --hidethinking  Explicitly hide model thinking process (default behavior)
  -h              Show this help message

Commands:
  pop list        Show all active and past pop sessions
  pop model       List all available Ollama models

Input Methods:
  1. Command-line argument: pop "write a script..."
  2. File input: pop -f prompt.txt
  3. Stdin: echo "write a script..." | pop

Examples:
  pop "write a python script that lists files"
  pop -m llama3.2 "write a csv parser" -o csvcut.py -l python
  pop -f my-prompt.txt -o output.sh -l bash
  echo "write a port scanner" | pop -o portscan.py
  cat requirements.txt | pop "create a script from these requirements"

Model Selection:
  Without -m flag, defaults to qwen3:latest.
  Use -m to specify a different model from: ollama list

Output Files:
  - Your script file (executable)
  - Session logs in ~/.pop/sessions/
EOF
}

# Function to list sessions
list_sessions() {
    echo -e "${CYAN}=== Past Sessions (Last 20) ===${NC}"

    local past_count=0
    if [ -d "$SESSIONS_DIR" ]; then
        # List sessions sorted by timestamp, oldest first (most recent last)
        for meta_file in $(ls -t "$SESSIONS_DIR"/*.meta 2>/dev/null | head -20 | tail -r); do
            if [ -f "$meta_file" ]; then
                source "$meta_file"
                local session_id=$(basename "$meta_file" .meta)

                # Check if this session is active
                if [ -f "$ACTIVE_DIR/$session_id.session" ]; then
                    continue  # Skip active sessions (shown below)
                fi

                local status_icon="✓"
                local status_color="$GREEN"
                if [ "$STATUS" = "failed" ]; then
                    status_icon="✗"
                    status_color="$RED"
                fi

                echo -e "${status_color}${status_icon}${NC} $session_id"
                echo -e "  Time: $START_TIME → $END_TIME"
                echo -e "  Model: $MODEL_NAME"
                echo -e "  Output: $OUTPUT_FILE"
                echo -e "  Prompt: ${PROMPT_TEXT:0:60}..."
                echo -e "  Log: $SESSIONS_DIR/$session_id.log"
                echo ""
                ((past_count++))
            fi
        done
    fi

    if [ $past_count -eq 0 ]; then
        echo -e "${YELLOW}No past sessions${NC}"
    fi

    echo ""
    echo -e "${CYAN}=== Active Sessions ===${NC}"

    local active_count=0
    if [ -d "$ACTIVE_DIR" ] && [ "$(ls -A "$ACTIVE_DIR" 2>/dev/null)" ]; then
        for session_file in "$ACTIVE_DIR"/*.session; do
            if [ -f "$session_file" ]; then
                local session_id=$(basename "$session_file" .session)
                local pid=$(cat "$session_file")

                if kill -0 "$pid" 2>/dev/null; then
                    # Process is still running
                    local session_meta="$SESSIONS_DIR/$session_id.meta"
                    if [ -f "$session_meta" ]; then
                        source "$session_meta"
                        echo -e "${GREEN}● ${NC}$session_id (PID: $pid)"
                        echo -e "  Started: $START_TIME"
                        echo -e "  Model: $MODEL_NAME"
                        echo -e "  Output: $OUTPUT_FILE"
                        echo -e "  Prompt: ${PROMPT_TEXT:0:60}..."
                        echo ""
                    fi
                    ((active_count++))
                else
                    # Process finished, clean up
                    rm -f "$session_file"
                fi
            fi
        done
    fi

    if [ $active_count -eq 0 ]; then
        echo -e "${YELLOW}No active sessions${NC}"
    fi

    exit 0
}

# Function to list available models
list_models() {
    echo -e "${CYAN}=== Available Ollama Models ===${NC}"

    local models=$(ollama list 2>/dev/null)

    if [ -z "$models" ]; then
        echo -e "${RED}✗ No models found or Ollama is not running${NC}"
        echo -e "${YELLOW}Install models with: ollama pull <model>${NC}"
        exit 1
    fi

    # Print the models (includes header from ollama list)
    echo "$models"

    exit 0
}

# Check if first argument is "list" or "model"
if [ "$1" = "list" ]; then
    list_sessions
fi

if [ "$1" = "model" ]; then
    list_models
fi

# Function to list and select model
select_model() {
    echo -e "${YELLOW}Available Ollama models:${NC}" >&2

    # Get list of models, skip header line
    local models=($(ollama list | tail -n +2 | awk '{print $1}'))

    if [ ${#models[@]} -eq 0 ]; then
        echo -e "${RED}✗ No Ollama models found. Install models with: ollama pull <model>${NC}" >&2
        exit 1
    fi

    # Display numbered list
    local i=1
    for model in "${models[@]}"; do
        echo "  $i) $model" >&2
        ((i++))
    done

    # Prompt for selection
    echo -n "Select model (1-${#models[@]}): " >&2
    read -r selection

    # Validate selection
    if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt ${#models[@]} ]; then
        echo -e "${RED}✗ Invalid selection${NC}" >&2
        exit 1
    fi

    # Return selected model (array is 0-indexed)
    echo "${models[$((selection-1))]}"
}

# Parse command-line arguments
# First handle long options
while [[ $# -gt 0 ]]; do
    case $1 in
        --minimal)
            MINIMAL_MODE=true
            shift
            ;;
        --hidethinking)
            HIDE_THINKING=true
            shift
            ;;
        --thinking)
            HIDE_THINKING=false
            shift
            ;;
        --)
            shift
            break
            ;;
        -*)
            break
            ;;
        *)
            break
            ;;
    esac
done

# Then handle short options
while getopts "m:f:o:l:h" opt; do
    case $opt in
        m) MODEL="$OPTARG" ;;
        f) INPUT_FILE="$OPTARG" ;;
        o) OUTPUT="$OPTARG" ;;
        l) LANG="$OPTARG" ;;
        h) show_usage; exit 0 ;;
        \?) echo "Invalid option: -$OPTARG" >&2; show_usage; exit 1 ;;
    esac
done

# Shift past the options
shift $((OPTIND-1))

# Determine input source (priority: file > stdin > argument)
if [ -n "$INPUT_FILE" ]; then
    # Read from file
    if [ ! -f "$INPUT_FILE" ]; then
        echo -e "${RED}✗ File not found: $INPUT_FILE${NC}" >&2
        exit 1
    fi
    PROMPT=$(cat "$INPUT_FILE")
elif [ ! -t 0 ]; then
    # Read from stdin (pipe)
    PROMPT=$(cat)
    # If there's also a command-line argument, append it
    if [ -n "$1" ]; then
        PROMPT="$1

$PROMPT"
    fi
elif [ -n "$1" ]; then
    # Read from command-line argument
    PROMPT="$1"
else
    echo -e "${RED}✗ No prompt provided${NC}" >&2
    show_usage
    exit 1
fi

# Validate prompt
if [ -z "$PROMPT" ]; then
    echo -e "${RED}✗ Empty prompt${NC}" >&2
    exit 1
fi

# Verify model exists
if ! ollama list | grep -q "^$MODEL"; then
    echo -e "${RED}✗ Model not found: $MODEL${NC}" >&2
    echo "Available models:" >&2
    ollama list >&2
    exit 1
fi

# Generate unique session ID
SESSION_ID="pop-$(date +%Y%m%d-%H%M%S)-$$"
SESSION_LOG="$SESSIONS_DIR/$SESSION_ID.log"
SESSION_META="$SESSIONS_DIR/$SESSION_ID.meta"
SESSION_ACTIVE="$ACTIVE_DIR/$SESSION_ID.session"

# Save session metadata
cat > "$SESSION_META" << EOF
START_TIME="$(date '+%Y-%m-%d %H:%M:%S')"
MODEL_NAME="$MODEL"
OUTPUT_FILE="$OUTPUT"
PROMPT_TEXT="$PROMPT"
STATUS="running"
END_TIME=""
EOF

# Background process function
run_generation() {
    local session_id="$1"
    local model="$2"
    local prompt="$3"
    local output="$4"
    local lang="$5"
    local log="$6"
    local meta="$7"
    local active="$8"
    local hide_thinking="$9"
    local minimal_mode="${10}"

    # Write session header to log
    {
        echo "=== pop Session: $session_id ==="
        echo "Started: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "Model: $model"
        echo "Output: $output"
        echo "Prompt: $prompt"
        echo ""
        echo "=== Generation Output ==="
    } >> "$log"

    # Build extract-code.py command (use script directory)
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    EXTRACT_CMD="$SCRIPT_DIR/extract-code.py"
    if [ -n "$lang" ]; then
        EXTRACT_CMD="$EXTRACT_CMD --lang $lang"
    fi
    if [ "$minimal_mode" = "true" ]; then
        EXTRACT_CMD="$EXTRACT_CMD --strip-comments"
    fi

    # Build ollama options array
    local ollama_opts=()
    if [ "$hide_thinking" = "true" ]; then
        ollama_opts+=(--hidethinking)
    fi

    # Build enhanced prompt with clear instructions for clean code
    if [ "$minimal_mode" = "true" ]; then
        # Stronger prompt for minimal mode
        local enhanced_prompt="$prompt

CRITICAL INSTRUCTIONS:
- Output ONLY executable code in a single code block
- NO explanations, NO comments, NO documentation
- NO text before or after the code block
- Code must be production-ready and executable immediately"
    else
        # Standard prompt enhancement
        local enhanced_prompt="$prompt

IMPORTANT: Respond with ONLY the executable code inside a single code block. No explanations, no comments, no text before or after the code block."
    fi

    # Run ollama and extract code
    local status="success"
    if ollama run "${ollama_opts[@]}" "$model" "$enhanced_prompt" | tee -a "$log" | $EXTRACT_CMD > "$output"; then
        if [ -s "$output" ]; then
            chmod +x "$output"
            echo "" >> "$log"
            echo "=== Result ===" >> "$log"
            echo "✓ Script saved to: $output" >> "$log"
            echo "✓ Session log: $log" >> "$log"
        else
            echo "" >> "$log"
            echo "✗ No code extracted. Check log for details." >> "$log"
            status="failed"
        fi
    else
        echo "" >> "$log"
        echo "✗ Code generation failed" >> "$log"
        status="failed"
    fi

    # Update metadata with completion status
    local end_time="$(date '+%Y-%m-%d %H:%M:%S')"
    sed -i.bak "s/STATUS=\"running\"/STATUS=\"$status\"/" "$meta"
    sed -i.bak "s/END_TIME=\"\"/END_TIME=\"$end_time\"/" "$meta"
    rm -f "$meta.bak"

    # Remove from active sessions
    rm -f "$active"
}

# Get incremental output filename to avoid overwriting
OUTPUT=$(get_output_filename "$OUTPUT")

# Update metadata with final output filename
sed -i.bak "s|OUTPUT_FILE=\".*\"|OUTPUT_FILE=\"$OUTPUT\"|" "$SESSION_META"
rm -f "$SESSION_META.bak"

# Start background generation
run_generation "$SESSION_ID" "$MODEL" "$PROMPT" "$OUTPUT" "$LANG" "$SESSION_LOG" "$SESSION_META" "$SESSION_ACTIVE" "$HIDE_THINKING" "$MINIMAL_MODE" &

# Get the background process PID and save to active session file
BG_PID=$!
echo "$BG_PID" > "$SESSION_ACTIVE"

# Inform user
echo -e "${GREEN}✓ pop session started: ${BLUE}$SESSION_ID${NC}"
echo -e "${GREEN}✓ Model: ${BLUE}$MODEL${NC}"
echo -e "${GREEN}✓ Output will be saved to: ${BLUE}$OUTPUT${NC}"
echo -e "${GREEN}✓ Session log: ${BLUE}$SESSION_LOG${NC}"
echo ""
echo -e "${YELLOW}Generation running in background (PID: $BG_PID)${NC}"
echo -e "${YELLOW}Use 'pop list' to check session status${NC}"
echo -e "${YELLOW}Use 'tail -f $SESSION_LOG' to follow progress${NC}"
