#!/bin/bash
# pop - Prompt-Oriented Programming: LLM Code Generator
# Usage: pop [options] [prompt]

set -e

# Default values
OUTPUT="script.py"
LANG=""
MODEL="qwen3:latest"
INPUT_FILE=""
PROMPT=""
HIDE_THINKING=true  # Hide thinking by default
MINIMAL_MODE=false  # Minimal mode disabled by default
VERIFY=true         # Verification enabled by default
MAX_RETRIES=3       # Maximum retry attempts for verification failures
POP_DIR="$HOME/.pop"
SESSIONS_DIR="$POP_DIR/sessions"
ACTIVE_DIR="$POP_DIR/active"

# Function to get incremental output filename
get_output_filename() {
    local base_output="$1"
    local output="$base_output"
    local counter=1

    # If file doesn't exist, use it as-is
    if [ ! -f "$output" ]; then
        echo "$output"
        return
    fi

    # Extract directory, basename, and extension
    local dir=$(dirname "$output")
    local filename=$(basename "$output")
    local name="${filename%.*}"
    local ext="${filename##*.}"

    # If no extension (e.g., "script"), treat whole name as basename
    if [ "$name" = "$ext" ]; then
        ext=""
    fi

    # Find available filename
    while [ -f "$output" ]; do
        if [ -n "$ext" ]; then
            output="${dir}/${name}-${counter}.${ext}"
        else
            output="${dir}/${filename}-${counter}"
        fi
        ((counter++))
    done

    echo "$output"
}

# Function to detect language from file
detect_language() {
    local file="$1"
    local specified_lang="$2"

    # Use specified language if provided
    if [ -n "$specified_lang" ]; then
        echo "$specified_lang"
        return
    fi

    # Check shebang first
    if [ -f "$file" ]; then
        local shebang=$(head -1 "$file" 2>/dev/null)
        if [[ "$shebang" == *"python"* ]]; then echo "python"; return; fi
        if [[ "$shebang" == *"bash"* ]] || [[ "$shebang" == *"/bin/sh"* ]]; then echo "bash"; return; fi
        if [[ "$shebang" == *"node"* ]]; then echo "javascript"; return; fi
        if [[ "$shebang" == *"ruby"* ]]; then echo "ruby"; return; fi
        if [[ "$shebang" == *"perl"* ]]; then echo "perl"; return; fi
    fi

    # Fall back to extension
    local ext="${file##*.}"
    case "$ext" in
        py) echo "python" ;;
        sh|bash) echo "bash" ;;
        js) echo "javascript" ;;
        rb) echo "ruby" ;;
        pl) echo "perl" ;;
        php) echo "php" ;;
        *) echo "unknown" ;;
    esac
}

# Function to verify syntax of generated code
verify_syntax() {
    local file="$1"
    local lang="$2"

    # Return empty string (success) if file doesn't exist or is empty
    if [ ! -s "$file" ]; then
        echo "File is empty or does not exist"
        return
    fi

    case "$lang" in
        python|py)
            python3 -m py_compile "$file" 2>&1 && echo ""
            ;;
        bash|sh|shell)
            bash -n "$file" 2>&1 && echo ""
            ;;
        javascript|js)
            if command -v node &> /dev/null; then
                node --check "$file" 2>&1 && echo ""
            else
                echo ""  # Can't verify, assume OK
            fi
            ;;
        ruby|rb)
            if command -v ruby &> /dev/null; then
                ruby -c "$file" 2>&1 | grep -v "Syntax OK" || echo ""
            else
                echo ""
            fi
            ;;
        perl|pl)
            if command -v perl &> /dev/null; then
                perl -c "$file" 2>&1 | grep -v "syntax OK" || echo ""
            else
                echo ""
            fi
            ;;
        *)
            echo ""  # Can't verify unknown languages, assume OK
            ;;
    esac
}

# Function to verify completeness using the model
verify_completeness() {
    local model="$1"
    local original_prompt="$2"
    local code_file="$3"
    local hide_thinking="$4"

    local code=$(cat "$code_file")

    local verify_prompt="You are a code reviewer. Analyze if this code fully implements the requirements.

ORIGINAL REQUIREMENTS:
$original_prompt

GENERATED CODE:
$code

Respond with ONLY valid JSON (no markdown, no code blocks, no explanation):
{\"complete\": true} if the code fully meets requirements and is syntactically complete
{\"complete\": false, \"issues\": [\"issue1\", \"issue2\"]} if incomplete or broken

Check for:
- Code appears truncated or cut off mid-statement
- Missing required functionality from the prompt
- Incomplete function definitions or class structures
- Missing imports or dependencies that would cause runtime errors"

    local ollama_opts=()
    if [ "$hide_thinking" = "true" ]; then
        ollama_opts+=(--hidethinking)
    fi

    # Run verification and capture response
    local response=$(ollama run "${ollama_opts[@]}" "$model" "$verify_prompt" 2>/dev/null)

    # Try to extract JSON from response (handle markdown code blocks)
    local json_response=$(echo "$response" | grep -o '{[^}]*}' | head -1)

    if [ -z "$json_response" ]; then
        # If no JSON found, assume complete (fail-safe)
        echo '{"complete": true}'
    else
        echo "$json_response"
    fi
}

# Function to extract issues from verification response
extract_issues() {
    local json="$1"
    # Extract issues array content, handling various formats
    echo "$json" | sed -n 's/.*"issues"[[:space:]]*:[[:space:]]*\[\([^]]*\)\].*/\1/p' | tr -d '"' | tr ',' '\n' | sed 's/^[[:space:]]*/- /'
}

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Create pop directories if they don't exist
mkdir -p "$SESSIONS_DIR" "$ACTIVE_DIR"

# Function to show usage
show_usage() {
    cat << EOF
Usage: pop [options] [prompt]

Generate code using Ollama models and extract it to executable files.

Options:
  -m MODEL        Select Ollama model (default: qwen3:latest)
  -f FILE         Read prompt from file
  -o OUTPUT       Output file path (default: script.py)
  -l LANG         Language filter for code extraction (python, bash, etc.)
  --minimal       Enable minimal mode (strongest prompts + strip comments)
  --thinking      Show model thinking process (hidden by default)
  --hidethinking  Explicitly hide model thinking process (default behavior)
  --no-verify     Skip output verification (verification enabled by default)
  -h              Show this help message

Commands:
  pop list        Show all active and past pop sessions
  pop model       List all available Ollama models

Verification:
  By default, pop verifies generated code for syntax errors and completeness.
  If verification fails, it automatically retries up to 3 times with feedback.
  Use --no-verify to skip verification for faster (but less reliable) output.

Input Methods:
  1. Command-line argument: pop "write a script..."
  2. File input: pop -f prompt.txt
  3. Stdin: echo "write a script..." | pop

Examples:
  pop "write a python script that lists files"
  pop -m llama3.2 "write a csv parser" -o csvcut.py -l python
  pop -f my-prompt.txt -o output.sh -l bash
  echo "write a port scanner" | pop -o portscan.py
  cat requirements.txt | pop "create a script from these requirements"

Model Selection:
  Without -m flag, defaults to qwen3:latest.
  Use -m to specify a different model from: ollama list

Output Files:
  - Your script file (executable)
  - Session logs in ~/.pop/sessions/
EOF
}

# Function to list sessions
list_sessions() {
    echo -e "${CYAN}=== Past Sessions (Last 20) ===${NC}"

    local past_count=0
    if [ -d "$SESSIONS_DIR" ]; then
        # List sessions sorted by timestamp, oldest first (most recent last)
        for meta_file in $(ls -t "$SESSIONS_DIR"/*.meta 2>/dev/null | head -20 | tail -r); do
            if [ -f "$meta_file" ]; then
                source "$meta_file"
                local session_id=$(basename "$meta_file" .meta)

                # Check if this session is active
                if [ -f "$ACTIVE_DIR/$session_id.session" ]; then
                    continue  # Skip active sessions (shown below)
                fi

                local status_icon="✓"
                local status_color="$GREEN"
                if [ "$STATUS" = "failed" ]; then
                    status_icon="✗"
                    status_color="$RED"
                fi

                echo -e "${status_color}${status_icon}${NC} $session_id"
                echo -e "  Time: $START_TIME → $END_TIME"
                echo -e "  Model: $MODEL_NAME"
                echo -e "  Output: $OUTPUT_FILE"
                echo -e "  Prompt: ${PROMPT_TEXT:0:60}..."
                echo -e "  Log: $SESSIONS_DIR/$session_id.log"
                echo ""
                ((past_count++))
            fi
        done
    fi

    if [ $past_count -eq 0 ]; then
        echo -e "${YELLOW}No past sessions${NC}"
    fi

    echo ""
    echo -e "${CYAN}=== Active Sessions ===${NC}"

    local active_count=0
    if [ -d "$ACTIVE_DIR" ] && [ "$(ls -A "$ACTIVE_DIR" 2>/dev/null)" ]; then
        for session_file in "$ACTIVE_DIR"/*.session; do
            if [ -f "$session_file" ]; then
                local session_id=$(basename "$session_file" .session)
                local pid=$(cat "$session_file")

                if kill -0 "$pid" 2>/dev/null; then
                    # Process is still running
                    local session_meta="$SESSIONS_DIR/$session_id.meta"
                    if [ -f "$session_meta" ]; then
                        source "$session_meta"
                        echo -e "${GREEN}● ${NC}$session_id (PID: $pid)"
                        echo -e "  Started: $START_TIME"
                        echo -e "  Model: $MODEL_NAME"
                        echo -e "  Output: $OUTPUT_FILE"
                        echo -e "  Prompt: ${PROMPT_TEXT:0:60}..."
                        echo ""
                    fi
                    ((active_count++))
                else
                    # Process finished, clean up
                    rm -f "$session_file"
                fi
            fi
        done
    fi

    if [ $active_count -eq 0 ]; then
        echo -e "${YELLOW}No active sessions${NC}"
    fi

    exit 0
}

# Function to list available models
list_models() {
    echo -e "${CYAN}=== Available Ollama Models ===${NC}"

    local models=$(ollama list 2>/dev/null)

    if [ -z "$models" ]; then
        echo -e "${RED}✗ No models found or Ollama is not running${NC}"
        echo -e "${YELLOW}Install models with: ollama pull <model>${NC}"
        exit 1
    fi

    # Print the models (includes header from ollama list)
    echo "$models"

    exit 0
}

# Check if first argument is "list" or "model"
if [ "$1" = "list" ]; then
    list_sessions
fi

if [ "$1" = "model" ]; then
    list_models
fi

# Function to list and select model
select_model() {
    echo -e "${YELLOW}Available Ollama models:${NC}" >&2

    # Get list of models, skip header line
    local models=($(ollama list | tail -n +2 | awk '{print $1}'))

    if [ ${#models[@]} -eq 0 ]; then
        echo -e "${RED}✗ No Ollama models found. Install models with: ollama pull <model>${NC}" >&2
        exit 1
    fi

    # Display numbered list
    local i=1
    for model in "${models[@]}"; do
        echo "  $i) $model" >&2
        ((i++))
    done

    # Prompt for selection
    echo -n "Select model (1-${#models[@]}): " >&2
    read -r selection

    # Validate selection
    if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -gt ${#models[@]} ]; then
        echo -e "${RED}✗ Invalid selection${NC}" >&2
        exit 1
    fi

    # Return selected model (array is 0-indexed)
    echo "${models[$((selection-1))]}"
}

# Parse command-line arguments
# First handle long options
while [[ $# -gt 0 ]]; do
    case $1 in
        --minimal)
            MINIMAL_MODE=true
            shift
            ;;
        --hidethinking)
            HIDE_THINKING=true
            shift
            ;;
        --thinking)
            HIDE_THINKING=false
            shift
            ;;
        --no-verify)
            VERIFY=false
            shift
            ;;
        --)
            shift
            break
            ;;
        -*)
            break
            ;;
        *)
            break
            ;;
    esac
done

# Then handle short options
while getopts "m:f:o:l:h" opt; do
    case $opt in
        m) MODEL="$OPTARG" ;;
        f) INPUT_FILE="$OPTARG" ;;
        o) OUTPUT="$OPTARG" ;;
        l) LANG="$OPTARG" ;;
        h) show_usage; exit 0 ;;
        \?) echo "Invalid option: -$OPTARG" >&2; show_usage; exit 1 ;;
    esac
done

# Shift past the options
shift $((OPTIND-1))

# Determine input source (priority: file > stdin > argument)
if [ -n "$INPUT_FILE" ]; then
    # Read from file
    if [ ! -f "$INPUT_FILE" ]; then
        echo -e "${RED}✗ File not found: $INPUT_FILE${NC}" >&2
        exit 1
    fi
    PROMPT=$(cat "$INPUT_FILE")
elif [ ! -t 0 ]; then
    # Read from stdin (pipe)
    PROMPT=$(cat)
    # If there's also a command-line argument, append it
    if [ -n "$1" ]; then
        PROMPT="$1

$PROMPT"
    fi
elif [ -n "$1" ]; then
    # Read from command-line argument
    PROMPT="$1"
else
    echo -e "${RED}✗ No prompt provided${NC}" >&2
    show_usage
    exit 1
fi

# Validate prompt
if [ -z "$PROMPT" ]; then
    echo -e "${RED}✗ Empty prompt${NC}" >&2
    exit 1
fi

# Verify model exists
if ! ollama list | grep -q "^$MODEL"; then
    echo -e "${RED}✗ Model not found: $MODEL${NC}" >&2
    echo "Available models:" >&2
    ollama list >&2
    exit 1
fi

# Generate unique session ID
SESSION_ID="pop-$(date +%Y%m%d-%H%M%S)-$$"
SESSION_LOG="$SESSIONS_DIR/$SESSION_ID.log"
SESSION_META="$SESSIONS_DIR/$SESSION_ID.meta"
SESSION_ACTIVE="$ACTIVE_DIR/$SESSION_ID.session"

# Save session metadata
cat > "$SESSION_META" << EOF
START_TIME="$(date '+%Y-%m-%d %H:%M:%S')"
MODEL_NAME="$MODEL"
OUTPUT_FILE="$OUTPUT"
PROMPT_TEXT="$PROMPT"
STATUS="running"
END_TIME=""
ATTEMPTS="0"
VERIFIED="false"
EOF

# Background process function
run_generation() {
    local session_id="$1"
    local model="$2"
    local original_prompt="$3"
    local output="$4"
    local lang="$5"
    local log="$6"
    local meta="$7"
    local active="$8"
    local hide_thinking="$9"
    local minimal_mode="${10}"
    local do_verify="${11}"
    local max_retries="${12}"

    # Write session header to log
    {
        echo "=== pop Session: $session_id ==="
        echo "Started: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "Model: $model"
        echo "Output: $output"
        echo "Verification: $do_verify"
        echo "Prompt: $original_prompt"
        echo ""
    } >> "$log"

    # Build extract-code.py command (use script directory)
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    local base_extract_cmd="$SCRIPT_DIR/extract-code.py"
    if [ -n "$lang" ]; then
        base_extract_cmd="$base_extract_cmd --lang $lang"
    fi
    if [ "$minimal_mode" = "true" ]; then
        base_extract_cmd="$base_extract_cmd --strip-comments"
    fi

    # Build ollama options array
    local ollama_opts=()
    if [ "$hide_thinking" = "true" ]; then
        ollama_opts+=(--hidethinking)
    fi

    # Verification loop
    local attempt=1
    local max_attempts=$((max_retries + 1))
    local status="success"
    local verified="false"
    local current_prompt="$original_prompt"
    local issues=""

    while [ $attempt -le $max_attempts ]; do
        echo "=== Generation Attempt $attempt/$max_attempts ===" >> "$log"

        # Build enhanced prompt with clear instructions for clean code
        local enhanced_prompt
        if [ "$minimal_mode" = "true" ]; then
            enhanced_prompt="$current_prompt

CRITICAL INSTRUCTIONS:
- Output ONLY executable code in a single code block
- NO explanations, NO comments, NO documentation
- NO text before or after the code block
- Code must be production-ready and executable immediately"
        else
            enhanced_prompt="$current_prompt

IMPORTANT: Respond with ONLY the executable code inside a single code block. No explanations, no comments, no text before or after the code block."
        fi

        # Run ollama and extract code
        if ollama run "${ollama_opts[@]}" "$model" "$enhanced_prompt" 2>&1 | tee -a "$log" | $base_extract_cmd > "$output"; then
            if [ -s "$output" ]; then
                chmod +x "$output"

                # Skip verification if disabled
                if [ "$do_verify" != "true" ]; then
                    echo "" >> "$log"
                    echo "=== Result (verification skipped) ===" >> "$log"
                    echo "✓ Script saved to: $output" >> "$log"
                    verified="skipped"
                    break
                fi

                # Detect language for syntax checking
                local detected_lang=$(detect_language "$output" "$lang")
                echo "" >> "$log"
                echo "=== Verification (attempt $attempt) ===" >> "$log"
                echo "Detected language: $detected_lang" >> "$log"

                # Step 1: Syntax verification
                local syntax_result=$(verify_syntax "$output" "$detected_lang")
                if [ -n "$syntax_result" ]; then
                    echo "✗ Syntax error: $syntax_result" >> "$log"
                    issues="Syntax error: $syntax_result"

                    if [ $attempt -lt $max_attempts ]; then
                        current_prompt="$original_prompt

IMPORTANT: Your previous attempt had a syntax error:
$syntax_result

Please generate COMPLETE, syntactically correct code that compiles/parses without errors."
                        ((attempt++))
                        continue
                    else
                        echo "✗ Max retries reached with syntax errors" >> "$log"
                        status="failed"
                        break
                    fi
                fi

                echo "✓ Syntax check passed" >> "$log"

                # Step 2: Completeness verification using the model
                echo "Running completeness check..." >> "$log"
                local completeness_result=$(verify_completeness "$model" "$original_prompt" "$output" "$hide_thinking")
                echo "Completeness result: $completeness_result" >> "$log"

                if echo "$completeness_result" | grep -q '"complete"[[:space:]]*:[[:space:]]*false'; then
                    issues=$(extract_issues "$completeness_result")
                    echo "✗ Completeness check failed:" >> "$log"
                    echo "$issues" >> "$log"

                    if [ $attempt -lt $max_attempts ]; then
                        current_prompt="$original_prompt

IMPORTANT: Your previous attempt was incomplete or had issues:
$issues

Please generate a COMPLETE, working implementation that addresses ALL requirements and issues above."
                        ((attempt++))
                        continue
                    else
                        echo "✗ Max retries reached, accepting best effort" >> "$log"
                        # Accept the code anyway since syntax is valid
                        verified="partial"
                        break
                    fi
                fi

                # All checks passed
                echo "✓ Completeness check passed" >> "$log"
                verified="true"
                break
            else
                echo "" >> "$log"
                echo "✗ No code extracted from response" >> "$log"
                issues="No code block found in response"

                if [ $attempt -lt $max_attempts ]; then
                    current_prompt="$original_prompt

IMPORTANT: Your previous response did not contain a properly formatted code block.
Please respond with ONLY executable code inside a markdown code block like:
\`\`\`python
# your code here
\`\`\`"
                    ((attempt++))
                    continue
                else
                    status="failed"
                    break
                fi
            fi
        else
            echo "" >> "$log"
            echo "✗ Code generation command failed" >> "$log"
            status="failed"
            break
        fi
    done

    # Final result
    echo "" >> "$log"
    echo "=== Final Result ===" >> "$log"
    echo "Attempts: $attempt" >> "$log"
    echo "Verified: $verified" >> "$log"

    if [ -s "$output" ] && [ "$status" = "success" ]; then
        echo "✓ Script saved to: $output" >> "$log"
        echo "✓ Session log: $log" >> "$log"
    elif [ -s "$output" ]; then
        echo "⚠ Script saved with issues to: $output" >> "$log"
    else
        echo "✗ No output generated" >> "$log"
    fi

    # Update metadata with completion status
    local end_time="$(date '+%Y-%m-%d %H:%M:%S')"
    sed -i.bak "s/STATUS=\"running\"/STATUS=\"$status\"/" "$meta"
    sed -i.bak "s/END_TIME=\"\"/END_TIME=\"$end_time\"/" "$meta"
    sed -i.bak "s/ATTEMPTS=\"0\"/ATTEMPTS=\"$attempt\"/" "$meta"
    sed -i.bak "s/VERIFIED=\"false\"/VERIFIED=\"$verified\"/" "$meta"
    rm -f "$meta.bak"

    # Remove from active sessions
    rm -f "$active"
}

# Get incremental output filename to avoid overwriting
OUTPUT=$(get_output_filename "$OUTPUT")

# Update metadata with final output filename
sed -i.bak "s|OUTPUT_FILE=\".*\"|OUTPUT_FILE=\"$OUTPUT\"|" "$SESSION_META"
rm -f "$SESSION_META.bak"

# Start background generation
run_generation "$SESSION_ID" "$MODEL" "$PROMPT" "$OUTPUT" "$LANG" "$SESSION_LOG" "$SESSION_META" "$SESSION_ACTIVE" "$HIDE_THINKING" "$MINIMAL_MODE" "$VERIFY" "$MAX_RETRIES" &

# Get the background process PID and save to active session file
BG_PID=$!
echo "$BG_PID" > "$SESSION_ACTIVE"

# Inform user
echo -e "${GREEN}✓ pop session started: ${BLUE}$SESSION_ID${NC}"
echo -e "${GREEN}✓ Model: ${BLUE}$MODEL${NC}"
echo -e "${GREEN}✓ Output will be saved to: ${BLUE}$OUTPUT${NC}"
if [ "$VERIFY" = "true" ]; then
    echo -e "${GREEN}✓ Verification: ${BLUE}enabled (max $MAX_RETRIES retries)${NC}"
else
    echo -e "${YELLOW}✓ Verification: ${BLUE}disabled${NC}"
fi
echo -e "${GREEN}✓ Session log: ${BLUE}$SESSION_LOG${NC}"
echo ""
echo -e "${YELLOW}Generation running in background (PID: $BG_PID)${NC}"
echo -e "${YELLOW}Use 'pop list' to check session status${NC}"
echo -e "${YELLOW}Use 'tail -f $SESSION_LOG' to follow progress${NC}"
